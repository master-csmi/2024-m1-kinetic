\documentclass{article}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage[colorlinks=true,allcolors=blue]{hyperref} % Ajout du package hyperref pour les liens
\title{Report, Kinetic project}
\author{Dorian Geraldes Pereira, Axel Demuth}
\date{March 2024}

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Project Context}

Our project is part of a larger initiative aimed at processing 
IFC files representing buildings to create 3D models for energy 
simulations with high-performance calculations. Within this project, there is a need to 
complete missing data in the IFC file to enable simulations 
of energy consumption and losses.

\section{Project Objective}

Within this project scope, the primary goal is to implement an efficient and accurate 
conversion process for Industry Foundation Classes (IFC) 
files representing buildings or cities into meshes compatible with the 
Kinetic algorithm. Subsequently, the Kinetic algorithm will be applied to these 
meshes to produce watertight models, facilitating the execution of finite element calculations.

The specific steps to be undertaken are as follows:

\begin{enumerate}   
    \item \textbf{Reading Process or Mesh Conversion :} From the IFC files we will have a 
    conversion in the stl or msh format,we will need to change the reading process to be able 
    to read mesh from those format if possible,if we cant then we will convert the STL 
    or MSH meshes into one of the formats accepted by the Kinetic algorithm, 
    such as .ply, .xyz, .las, .off.
    
    \item \textbf{Application of the Kinetic Algorithm:} Applicate  
    the Kinetic algorithm on the the converted 
    meshes to produce meshes optimized for finite element calculations.
    
    \item \textbf{Recovery of Material Labels:} Ensure the preservation 
    of information regarding materials present in the initial IFC-format mesh 
    and correctly associate them with elements of the converted mesh.
    
    \item \textbf{Utilization on City Modeling:} Extend the application of 
    the Kinetic algorithm to entire city models.
\end{enumerate}

\section{Current Project Challenges}

Currently, the project faces several technical challenges:

\begin{enumerate}
    \item \textbf{Reading Process or Mesh Conversion:} we need to see if its possible to replace the read\_point\_set function by a read\_STL
    function producing a Point range instead of Point set if we cant we will need to find a
    solutions to convert meshes from STL or MSH files into one of the formats accepted by the Kinetic algorithm.
    
    \item \textbf{Parameter Optimization:} Identify and adjust appropriate 
    parameters to avoid segmentation faults and achieve satisfactory results 
    when applying the Kinetic algorithm.
    
    \item \textbf{Version Differences:} Understand the distinctions between 
    versions of the Kinetic algorithm,developed by CGAL and INRIA, to select 
    the right parameters to get the best result
\end{enumerate}

By overcoming these challenges, the project aims to provide a 
comprehensive and efficient solution for analyzing urban structures 
using the Kinetic algorithm to facilitate finite element calculations.\newline

\section{Tools}
\subsection{CGAL}
CGAL is a comprehensive package for geometry algorithms, providing various data structures and algorithms for working on polygons, surfaces, mesh generation, and more.
It offers a wide range of functionalities for geometric processing and analysis in various fields such as computer graphics, computational geometry, and geometric modeling.
\subsection{IFC project}

The initiative was created by buildingSMART (BIM), with the goal of supporting portability between software in the construction sector.
 IFC is a file format designed to replace a fragmented information system with a standardized one.
  This enables every actor in the sector to utilize IFC-compatible software to open files and model their contents without wasting time and computational resources on convertion between different formats.

The IFC format is based on object-oriented code, with numerous classes associated with various needs such as construction sites, tools, and materials.
However, a challenge we face is the difficulty in interpreting IFC objects for use in Kinetic programs. While there are several software solutions available to convert IFC to the desired format, 
we often lose significant amounts of information in the process.

As a result, we need to focus on refining the objects received from the converting process to ensure that Kinetic algorithms can effectively read the files.

\subsection{Kinetic}

Kinetic algorithms(KSR) is a package from CGAL that allows working on meshes with 
some holes in them. When applied to the mesh, the Kinetic algorithms will 'extend' some surfaces to fill the mesh and make it watertight. 
Here's what the algorithm is capable of:


\begin{figure}[H]
    
\includegraphics[scale =   0.3 ]{../../images/example_algorithm.png}

\end{figure}

We can obtain a comprehensive understanding of how it works in general from the report by INRIA \cite{yu:hal-03621896}.

\begin{itemize}
\item It uses geometric primitives to create planes due to their relevance in human-made environments.
\item There are multiple methods for plan fitting in a 3D model, such as Neural Network architectures or Energy-based Models. The algorithm employs the latter.
\item To evaluate the quality of a primitive configuration x with an energy U of the format
  \newline 
  $        U(x) = w_f U_f(x) + w_s U_c(x) + w_c U_c(x)       $
  \newline
  where all U functions pertain to fidelity, simplicity, and completeness, and all w are positive and weight.
  \item It then utilizes geometric operations such as merging, splitting, transfer, insertion, and exclusion on different planes and closed primitives.
\end{itemize}
  Here, we present pseudocode detailing how the exploration of the set of primitives works:
\begin{center}
  \includegraphics[scale =  0.5]{../../images/Pseudo_code_exploration.png}
\end{center}
The priority queue represents the set of primitives to which we apply geometric applications.

To use the algorithm, we employ one from CGAL. Given a set of parameters and a file containing a point cloud along with the associated normals to the points,
the algorithm is applied. We were fortunate to have a meeting with Florent Lafarge, one of the creators of the algorithm,
who explained to us which parameters are crucial for analysis and how each one can significantly influence the results.
Two parameters stand out as particularly important: 
\begin{itemize}
  \item 'dist' indicates the distance between two points required to consider them for plane construction.
  \item 'pmin' represents the number of points used to construct a plane.
\end{itemize}

In order to understand how these parameters affect the outcome, we will examine the same point cloud while varying the value of 'pmin' first and then varying 'dist.'
The algorithm produces .off files as output, which can be visualized using software such as MeshLab.

\newpage
The original point cloud represents this building:
\vspace{\baselineskip}

\begin{center}
    \includegraphics[scale=0.20]{../../images/screen_kinetic/building.png} 
\end{center}



\begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_pmin220.png}
      \caption{dist1\_pmin220}
      \label{fig:dist1_pmin220}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_pmin250.png}
      \caption{dist1\_pmin250}
      \label{fig:dist1_pmin250}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_pmin280.png}
      \caption{dist1\_pmin280}
      \label{fig:dist1_pmin280}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}

        \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_pmin300.png}
        \caption{dist1\_pmin300}
        \label{fig:dist1_pmin300}
      \end{minipage}
  \end{figure}
  
  First, it's important to understand that setting 'pmin' too low can lead to errors. Subsequently,if 'pmin' is too small, we may not capture enough structural detail,
  whereas setting 'pmin' too high may cause planes to overlap, resulting in loss of information



  \begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_5_pmin_250.png}
      \caption{dist15\_pmin250.png}
      \label{fig:dist15_pmin220}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist1_pmin250.png}
      \caption{dist1\_pmin250}
      \label{fig:dist1_pmin250}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist_0_3_pmin_250.png}
      \caption{dist03\_pmin250}
      \label{fig:dist03_pmin250}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}

        \includegraphics[width=\textwidth]{../../images/screen_kinetic/dist_001_pmin_250.png}
        \caption{dist001\_pmin250}
        \label{fig:dist1_pmin300}
      \end{minipage}
    \begin{minipage}[b]{0.45\textwidth}

        \includegraphics[width=\textwidth]{../../images/screen_kinetic/back_dist001_pmin250.png}
        \caption{dist001\_pmin250}
        \label{fig:dist1_pmin300}
      \end{minipage}
  \end{figure}


  When considering the 'dist' parameter, if it is set too high, we risk losing significant structural details. 
  In the opposite, if the distance is too small, surfaces may be divided into too many planes, potentially resulting in an incomplete coverage of the entire mesh, 
  as observed at the rear of the building with a 'dist' of 0.001.

  One of the challenges in studying this algorithm is determining the appropriate 'qmin' and 'dist' to achieve the desired number of space partitions.
  Setting it too high may enhance precision but extend execution time, and in some cases, incorrect values can lead to program crashes.

This algorithm could be a crucial tool in our project, particularly when dealing with massive meshes for large buildings,
hospitals, etc. When creating large meshes, issues can arise, and errors within the mesh can be detrimental during simulations,potentially leading to false results. 
This algorithm allows us to rectify such mesh problems.

One limitation of the algorithm is its input requirement, as it currently only works with scatter plots. Consequently, we are unable to utilize the IFC format, 
resulting in the loss of valuable information regarding the types of structures present. To address this limitation, 
we plan to implement a process involving the conversion of IFC to scatter plot with associated data, followed by conversion to formats such as .plt, .ply, .xyz,
which are supported by Kinetic CGAL, ultimately resulting in a mesh with associated data.


\section{Implementation}

We are using the most complete example of the cgal kinetic algorithm as base for our main. In this main we can change every parameters of the algorithm.
\newline
To use the algorithm we currently need to give him a file from supported format such as .ply , .off, .xyz, .las .
We will try to change it to be able to read STL and MSH format.
If the parameters dont respeced the critera we described in the previous section the algorithm can end up in segmentation fault.
The result of the algorithm will be in an .off format in "resultat" folder.
\newline
We can present an example of the command to execute the program :
\newline
" ./build/default/bin/kinetic -data data/flame.ply -dist 0.3 -minp 50 -regangle 5  "
\newline


\subsection{STL Reading and Use}

In the CGAL library, we have methods to read various file formats such as ply, off, xyz, and there is one for STL files. If we use the read\_stl function, we get the following output:

\begin{itemize}
  \item a list of all points used in the mesh
  \item a list of vertices with all points used in every polygon
\end{itemize}

So, we have access to a point cloud and a list of polygons. The KSR algorithm only needs a point cloud to work.
We then proceed to calculate the normals associated with all points, write all the points and the normals into an .xyz file, then read the .xyz file with our main program to apply the KSR algorithm.
However, one issue with STL files is the low number of points given by the files, so the algorithm doesn't work well with that, and an error is generated.
As a result, we need to find a way to densify our point cloud.

To execute KSR on our files we tried different option :

\begin{itemize}
  \item use a free open sourced software as CloudCompare  
  \item use CGAL method to densified our point cloud with function as CGAL poisson surface reparation.
\end{itemize}

\subsection{CloudCompare}
We used CloudCompare to create a densified point cloud with an stl file as basis.
This software can also calculate normals of each point, we used it sometimes to 
see the differences with cgal and meshlab version 



\subsection{CGAL method}
CGAL has multiple way to generate point cloud in theory, for example:
\begin{itemize}
  \item $CGAL::Spatial\_sort\_traits\_adapter\_3,CGAL::natural\_neighbor\_coordinates\_3()$, Interpolate method like moindres carre or spatiale interpolation  
  \item $CGAL::Delaunay\_triangulation\_3 Delaunay triangulation$ allow to creat a point cloud on a triangle  
  \item $CGAL::point\_generators\_3::regular\_grid\_points()$ generation on a grid 
\end{itemize}

If we succeed to generate a big enough point cloud with one of those function, we could try to write it in some off,xyz,ply files to read them and try to assemblate the mesh and to get the result we want.


\section{Analysis of results}
\subsection{first results}
Analysis of the meshes reveals significant differences between those produced by the CGAL algorithm and those generated by the INRIA algorithm. The final mesh obtained with CGAL demonstrates satisfactory watertightness but is characterized by noticeable roughness. Conversely, the final mesh generated by the INRIA algorithm is remarkably smoother, offering a more uniform surface.

For better visual understanding, three images are provided below:

\begin{itemize}
    \item Initial point cloud
    \item Result of the mesh with the CGAL algorithm
    \item Result of the mesh with the INRIA algorithm
\end{itemize}

\vspace{0.5cm}
\begin{figure}[h]
\centering
\includegraphics[width=0.25\textwidth]{../../images/screen_kinetic/building_point.png}
\hspace{0.05\textwidth}
\includegraphics[width=0.25\textwidth]{../../images/screen_kinetic/building_cgal.png}
\hspace{0.05\textwidth}
\includegraphics[width=0.25\textwidth]{../../images/screen_kinetic/building_inria.png}
\caption{Visualization of results with a building}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\textwidth]{../../images/screen_kinetic/flame_point.png}
    \hspace{0.05\textwidth}
    \includegraphics[width=0.29\textwidth]{../../images/screen_kinetic/flame_cgal.png}
    \hspace{0.05\textwidth}
    \includegraphics[width=0.22\textwidth]{../../images/screen_kinetic/flame_inria.png}
    \caption{Visualization of results with a flame}
    \end{figure}

\subsection{Final Result}

For the final analysis we worked on 2 of the example provided by Vincent Chabannes:
\vspace{0.5cm}
\begin{figure}[h]
  \centering
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/3zones.png}
    \caption*{3zones}
  \end{minipage}
  \hspace{0.05\textwidth}
  \begin{minipage}[t]{0.27\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin.png}
    \caption*{ACJasmin}
  \end{minipage}
  \hspace{0.05\textwidth}
  \begin{minipage}[t]{0.27\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_inside.png}
    \caption*{ACJasmin\_inside}
  \end{minipage}
\end{figure}  

For the first example, 3zones, 
we used CloudCompare to create the PLY point cloud file for the CGAL algorithm, 
and we calculated the necessary normals in Meshlab, which gave us the best results. 
However, the resulting watertight mesh lost all the details from the STL file,
such as the windows and doors, which have disappeared.

\vspace{0.5cm}
\begin{figure}[h]
  \centering
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/3zones_point_cloud.png}
    \caption*{3zones point cloud}
  \end{minipage}
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/3zones_result_normal5_cgal.png}
    \caption*{3zones result normal by MeshLab}
  \end{minipage}
  \begin{minipage}[t]{0.27\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/3zones_result_normal_cgal.png}
    \caption*{3zones result normal by cgal}
  \end{minipage}
\end{figure}  

For the second example, ACJasmin we used the same protocol as the first example but for 
this example we decided to remove the ground around the house because it created a lot of problems,
the result we got were a lot more disapointed than the first example.
The mesh we got wasnt watertight and we lost nearly every detail like the first example 
just a bit of the stairs still remained
the result we got from the cgal version was very bad:
\begin{figure}[h]
  \centering
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_point_cloud.png}
    \caption*{ACJasmin point cloud}
  \end{minipage}
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_primitive_cgal.png}
    \caption*{ACJasmin primitives by cgal}
  \end{minipage}
  \begin{minipage}[t]{0.27\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_result_CGAL.png}
    \caption*{ACJasmin result by cgal}
  \end{minipage}
\end{figure}  

after the cgal version we tried the IRNIA version the result was still disapointing but better 
\begin{figure}[h]
  \centering
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_point_cloud.png}
    \caption*{ACJasmin point cloud}
  \end{minipage}
  \begin{minipage}[t]{0.29\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_primitive.png}
    \caption*{ACJasmin primitives by INRIA}
  \end{minipage}
  \begin{minipage}[t]{0.27\textwidth}
    \includegraphics[width=\textwidth]{../../images/screen_kinetic/ACJasmin_result_INRIA.png}
    \caption*{ACJasmin result normal by INRIA}
  \end{minipage}
\end{figure}  

\section{Roadmap}
At this point those are the main Issues that we will need to work on:
\begin{itemize}
  
  \item Change the reading process to accept stl or msh format file or if its not possible
  convert PLT or MSH meshes into a format compatible with the Kinetic algorithm.
  \item If possible, be able to retrieve the labels on the mesh generated by the Kinetic algorithm.
  \item Quality check of the obtained mesh from the kinetic algorithm (same volume as the first mesh)
  \item Apply physical theories to the base mesh and the output mesh to analyze the differences between them.
  \item Investigate the feasibility of applying the algorithm on a larger scale, such as a city or a large building, instead of a basic one.
\end{itemize}

For the V1 we modified and completed some issues :
\begin{itemize}
  \item The Issues Create watertight mesh with kinetic we completed what we wanted to do with this issue but now we want to go further so we modified it 
  to create watertight mesh from files coming to IFC format for the V2
  \item The issue Convert IFC to .ply format was also changed to change the reading process or convert MSH and STL to supported cgal format for the V2
  \item The issue setup programming environment for CGAL with github action and submodul,the creation of the main program,the study of the kinetic program were completed 
\end{itemize}

    
\nocite{*}
\section{Reference}
\bibliographystyle{plain}
\bibliography{../../bibliography/v1/report_bib}
\end{document}